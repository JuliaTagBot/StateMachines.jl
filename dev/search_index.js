var documenterSearchIndex = {"docs":
[{"location":"usage/#User-guide-1","page":"Usage","title":"User guide","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"CurrentModule = StateMachines","category":"page"},{"location":"usage/#Installation-1","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"StateMachines.jl can be – once it is registered – installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add StateMachines","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"`The development version is installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add(\"https://github.com/pbayer/StateMachines.jl\")","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The package is then loaded with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"using StateMachines","category":"page"},{"location":"usage/#System-description-1","page":"Usage","title":"System description","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A system has different levels, which are used to hide complexity.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Id\nSystem\nBox\nBlock","category":"page"},{"location":"usage/#StateMachines.Id","page":"Usage","title":"StateMachines.Id","text":"Id\n\nAn identifier used to identify and to register system components.\n\n\n\n\n\n","category":"type"},{"location":"usage/#StateMachines.System","page":"Usage","title":"StateMachines.System","text":"An common supertype for Box, Block and StateMachine.\n\n\n\n\n\n","category":"type"},{"location":"usage/#StateMachines.Box","page":"Usage","title":"StateMachines.Box","text":"Box(id::Id, clk::Clock)\n\nA box is the outermost container of blocks and state machines. It has a clock, a composite state and one or more input/output channels. It cannot contain other boxes, but it can interact with other boxes.\n\nArguments, Fields\n\nid::Id: an identifier string\nclk::Clock: the system clock, this may be a clock shared with other boxes,\nstate::State:\ngate::Dict{Id, Channel}: a dictionary of channels,\nchild::Dict{Id, System}: a dictionary of registered blocks or state machines.\n\n\n\n\n\n","category":"type"},{"location":"usage/#StateMachines.Block","page":"Usage","title":"StateMachines.Block","text":"Block(id::Id, surr::System)\n\nA block is a container of blocks and state machines. It has one or more input/output channels. It registers to a system Box or to an higher block. It has a composite state.\n\nArguments, Fields\n\nid::Id: each block in a surrounding has to have an unique identifier,\nsurr::System: this links to the surrounding system Block or Box,\ncstate::State: a composite state of the underlying system,\ngate::Dict{Id, Channel}: a dictionary of channels,\nchild::Dict{Id, System}: a dictionary of registered blocks or state machines.\n\n\n\n\n\n","category":"type"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Behavior and StateMachine are used to describe the activities of a system","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"Behavior\nStateMachine","category":"page"},{"location":"usage/#StateMachines.Behavior","page":"Usage","title":"StateMachines.Behavior","text":"Behavior\n\nState machines implement different behaviors. Therefore we have this abstract type to differentiate between state machines and to correctly dispatch on them.\n\nExample\n\nusing StateMachines, Simulate\n\nstruct B1 <: Behavior end              # define the behaviors\nstruct B2 <: Behavior end\n\nS1 = Box(\"Box\", 𝐶)                     # define the environment,\nBlk1 = Block(\"Blk1\", S1)               # maybe containing one or more blocks\n\nSM1 = StateMachine(\"SM1\", B1(), Blk1)  # create state machine variables with\nSM2 = StateMachine(\"SM2\", B2(), Blk1)  # specified behaviors and suroundings\n\nfunction step!(A::StateMachine{B1}, ::Idle, σ::Load)  # transition functions\n    [....]                                            # implement the behaviour\nend\nfunction step!(A::StateMachine{B1}, ::Busy, σ::Fail) = [....]\nfunction step!(A::StateMachine{B1}, ::Failed, ::Repair) = [....]\n[....]\n\nwhile true                           # later at runtime ...\n    event = put!(SM1.gate[“in”])     # an event is read from an input channel\n    step!(SM1, event)                # and a state machine transition is called\nend\n\n\n\n\n\n","category":"type"},{"location":"usage/#StateMachines.StateMachine","page":"Usage","title":"StateMachines.StateMachine","text":"StateMachine{M}(id::Id, m::M, surr::System) where {M <: Behavior}\nStateMachine(id::Id, m::Behavior, surr::System)\n\nA state machine operates a Behavior. It has at least one input/output channel. It registers to a Block or a System.\n\nArguments, Fields\n\nid::Id: each process in a box or a block has to have an unique identifier,\nm::M: a model identifier,\ncstate::State: the composite state of the state machine,\nsurr::System: links to the surrounding Block or System,\ngate::Dict{Id, Channel}: events and tokens flow through the gates, each gate   has an unique identifier.\nstate::State: the internal state is used to operate the state machine,\nvar::Dict{Id, Any}: a dictionary of local variables, each with a unique Id.\nchild::Dict{Id, System}: a dictionary of registered sub machines.\n\n\n\n\n\n","category":"type"},{"location":"usage/#State-machines-1","page":"Usage","title":"State machines","text":"","category":"section"},{"location":"usage/#States-1","page":"Usage","title":"States","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"usage/#Events-1","page":"Usage","title":"Events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"usage/#Transitions-1","page":"Usage","title":"Transitions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"step!","category":"page"},{"location":"usage/#StateMachines.step!","page":"Usage","title":"StateMachines.step!","text":"step!(A::StateMachine, q::State, σ::SEvent)\n\ntransition function δ causing a state machine A in state q₁ at event σ to take on a new state q₂.\n\nFor all specified transitions Δ: Q × Σ → P(Q) of A a step!-function has to be implemented. For unspecified transitions a fallback step function is called and a warning is generated.\n\nArguments\n\nA::StateMachine: a state machine\nq::State: any state ∈ Q\nσ::SEvent: any discrete event ∈ Σ\n\n\n\n\n\n","category":"function"},{"location":"usage/#Operation-1","page":"Usage","title":"Operation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Programs-1","page":"Examples","title":"Programs","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"are at https://github.com/pbayer/StateMachines.jl/tree/master/docs/examples","category":"page"},{"location":"examples/#Notebooks-1","page":"Examples","title":"Notebooks","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"see https://github.com/pbayer/StateMachines.jl/tree/master/docs/notebooks","category":"page"},{"location":"overview/#A-framework-for-state-machines-1","page":"Overview","title":"A framework for state machines","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"State machines can be used to describe or implement discrete event systems. Julia with its multiple dispatch system is particularly practical in this regard. StateMachines.jl provides a framework to allow a straightforward implementation of interacting state machines.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"(Image: UML class diagram)","category":"page"},{"location":"overview/#System-box-1","page":"Overview","title":"System box","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In order to avoid confusion with the fuzzy meaning of the word \"system\", we declare System as an abstract type used for different things and take a Box as the outermost boundary of the system we interact with. A box contains blocks and processes. It has a clock, a composite state and one or more input/output channels.","category":"page"},{"location":"overview/#Block-1","page":"Overview","title":"Block","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"A Block is optional and a container of other blocks and processes and resides inside a Box or another Block. It can hide deeper and more intricate processes behind a simple interface. It has a composite state and one or more input/output channels.","category":"page"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In a structural view it contains several entities like servers in a server farm or facilities and medical staff in an emergency room. From a behavioral standpoint it represents a composite state like Down() or Alerted() or a domain event, consisting of several structural events like maintenance steps or emergency procedures.   ","category":"page"},{"location":"overview/#State-machine-1","page":"Overview","title":"State machine","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"A StateMachine is the basic operating unit of our framework. It implements the Behavior and the actions of the system, reacts to events and changes system states. A state machine has a composite state and represents a behavior through transitions between states and may contain sub state machines.","category":"page"},{"location":"overview/#State-1","page":"Overview","title":"State","text":"","category":"section"},{"location":"overview/#Event-1","page":"Overview","title":"Event","text":"","category":"section"},{"location":"overview/#Transition-1","page":"Overview","title":"Transition","text":"","category":"section"},{"location":"overview/#Action-1","page":"Overview","title":"Action","text":"","category":"section"},{"location":"#StateMachines.jl-1","page":"Home","title":"StateMachines.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"StateMachines.jl provides a practical way to describe, model and simulate communicating and queueing systems  in Julia.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A System has different representations or levels:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The outer Box provides a clock and an interface to the environment and contains blocks and processes.\nA Block` can be nested and used to construct more and deeper system levels. It contains blocks and processes.\nA StateMachine is used to implement the system Behavior with defined transitions between states. Through actions state machines change their environment and communicate with other processes or blocks via channels.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"StateMachines.jl is not yet an registered package and is installed with","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add(\"https://github.com/pbayer/StateMachines.jl\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"}]
}
