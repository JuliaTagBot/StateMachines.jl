var documenterSearchIndex = {"docs":
[{"location":"usage/#User-guide-1","page":"Usage","title":"User guide","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"CurrentModule = StateMachines","category":"page"},{"location":"usage/#Installation-1","page":"Usage","title":"Installation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"StateMachines.jl can be – once it is registered – installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add StateMachines","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"`The development version is installed with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"pkg> add(\"https://github.com/pbayer/StateMachines.jl\")","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"The package is then loaded with","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"using StateMachines","category":"page"},{"location":"usage/#System-description-1","page":"Usage","title":"System description","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"A system has different levels, which are used to hide complexity.","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"System\nBox\nBlock","category":"page"},{"location":"usage/#StateMachines.System","page":"Usage","title":"StateMachines.System","text":"An abstract type for Box, Block and Process.\n\n\n\n\n\n","category":"type"},{"location":"usage/#StateMachines.Box","page":"Usage","title":"StateMachines.Box","text":"Box(id::Id, clk::Clock)\n\nA box is the outermost container of blocks and processes. It has one or more input channels and one or more output channels. It cannot contain other boxes, but it can interact with other boxes.\n\nArguments, Fields\n\nid::Id: an identifier string\nclk::Clock: the system clock, this may be a clock shared with other boxes,\nstate::State:\ngate::Dict{Id, Channel}: a dictionary of channels,\nchilds::Dict{Id, System}: a dictionary of registered blocks or processes.\n\n\n\n\n\n","category":"type"},{"location":"usage/#StateMachines.Block","page":"Usage","title":"StateMachines.Block","text":"Block(id::Id, surr::System)\n\nA block is a container of blocks and processes. It has one or more input and one or more output channels. It registers to a System.\n\nArguments, Fields\n\nid::Id: each block in a surrounding has to have an unique identifier,\nsurr::System: this links to the surrounding Block or System,\nstate::State:\ngate::Dict{Id, Channel}: a dictionary of channels,\nchilds::Dict{Id, System}: a dictionary of registered agents.\n\n\n\n\n\n","category":"type"},{"location":"usage/#","page":"Usage","title":"Usage","text":"StateMachine and Process are used to describe the activities of a system:","category":"page"},{"location":"usage/#","page":"Usage","title":"Usage","text":"StateMachine\nProcess","category":"page"},{"location":"usage/#StateMachines.StateMachine","page":"Usage","title":"StateMachines.StateMachine","text":"StateMachine\n\nAn abstract type for StateMachines. It is used to declare concrete state machines in an implementation.\n\nExample\n\nusing StateMachines, Simulate\n\nstruct SM1 <: StateMachine end       # first you declare some state machine types\nstruct SM2 <: StateMachine end       # you want to use\n\nS1 = Box(\"Box\", 𝐶)                   # then you build a system,\nB1 = Block(\"B1\", S1)                 # maybe containing one or more blocks\n\nP1 = Process(\"P1\", SM1(), B1)        # processes inside a block act as state machines\nP2 = Process(\"P2\", SM2(), B1)\n\nfunction step!(A::Process{SM1}, ::Idle, σ::Load)  # transition functions define the\n    [....]                                        # activities of a process, maybe\nend                                               # using other functions\nfunction step!(A::Process{SM1}, ::Busy, σ::Fail) = [....]\nfunction step!(A::Process{SM1}, ::Failed, ::Repair) = [....]\n[....]\n\nwhile true                           # later at runtime\n    event = put!(P1.gate[“in”])      # an event is read from an input channel\n    step!(P1, P1.state, event)       # and a process transition is called\nend                                  # depending on its state and an incoming event\n\n\n\n\n\n","category":"type"},{"location":"usage/#StateMachines.Process","page":"Usage","title":"StateMachines.Process","text":"Process{SM}(id::Id, sm::SM, surr::System) where {SM <: StateMachine}\n\nA process is a container for a state machine. It cannot contain other processes. It has one input and one output channel. It registers to a Block or a System.\n\nArguments, Fields\n\nid::Id: each process in a box or a block has to have an unique identifier,\nsm::SM: a state machine identifier\nsurr::System: links to the surrounding Block or System,\nstate::State: this is read and changed by the process's state machine,\ngate::Dict{Id, Channel}: events and tokens flow through the gates, each gate   has an unique identifier.\n\n\n\n\n\n","category":"type"},{"location":"usage/#State-machines-1","page":"Usage","title":"State machines","text":"","category":"section"},{"location":"usage/#States-1","page":"Usage","title":"States","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"usage/#Events-1","page":"Usage","title":"Events","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"usage/#Transitions-1","page":"Usage","title":"Transitions","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"usage/#Operation-1","page":"Usage","title":"Operation","text":"","category":"section"},{"location":"usage/#","page":"Usage","title":"Usage","text":"","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Programs-1","page":"Examples","title":"Programs","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"are at https://github.com/pbayer/StateMachines.jl/tree/master/docs/examples","category":"page"},{"location":"examples/#Notebooks-1","page":"Examples","title":"Notebooks","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"see https://github.com/pbayer/StateMachines.jl/tree/master/docs/notebooks","category":"page"},{"location":"overview/#A-framework-for-state-machines-1","page":"Overview","title":"A framework for state machines","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"State machines can be used to describe or implement discrete event systems. Julia with its multiple dispatch system is particularly practical in this regard. StateMachines.jl provides a framework to allow a straightforward implementation of interacting state machines.","category":"page"},{"location":"overview/#Systems-1","page":"Overview","title":"Systems","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"In order to avoid confusion with the fuzzy meaning of the word \"system\", we declare System as an abstract type used for different things and take a Box as the outermost boundary of the system we interact with. A box contains blocks and processes.","category":"page"},{"location":"overview/#Blocks-1","page":"Overview","title":"Blocks","text":"","category":"section"},{"location":"overview/#","page":"Overview","title":"Overview","text":"A Block is a container of other blocks and processes and resides inside a Box or another Block. It is used to hide complexity of interacting processes to the outside by providing only the needed gates as a simple interface.","category":"page"},{"location":"overview/#Processes-and-state-machines-1","page":"Overview","title":"Processes and state machines","text":"","category":"section"},{"location":"#StateMachines.jl-1","page":"Home","title":"StateMachines.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"StateMachines.jl provides a Julia framework to describe, model and simulate communicating and queueing systems. A system has different incarnations or levels: ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"the outer box providing a clock and an interface to the environment and containing blocks and processes.\nBlocks can be nested and used to construct more and deeper levels.\nProcesses are the basic operating units and behave as state machines with defined transitions between their states. Through their activities processes can change their environment and communicate with other processes or blocks via channels.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"StateMachines.jl is not yet an registered package and is installed with","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add(\"https://github.com/pbayer/StateMachines.jl\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Author: Paul Bayer License: MIT","category":"page"},{"location":"internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"}]
}
